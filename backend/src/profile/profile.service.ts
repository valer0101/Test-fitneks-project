// backend/src/profile/profile.service.ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { JwtService } from '@nestjs/jwt';

@Injectable()
export class ProfileService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly jwtService: JwtService,
  ) {}

  async getProfile(userId: number) {
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
      select: {
        id: true,
        email: true,
        username: true,
        displayName: true,
        bio: true,
        location: true,
        timezone: true,
        workoutTypes: true,
        goals: true,
        muscleGroups: true,
        profilePictureUrl: true,
        role: true,
        onboardingCompleted: true,
        createdAt: true,
        updatedAt: true,
        xp: true,
        level: true,
        rubies: true,
        proteinShakes: true,
        proteinBars: true,
        profileBoosts: true,
        notifyBoosts: true,
        unlockedGifts: true,
        lastStreamCompletedAt: true,
      },
    });

    if (!user) {
      throw new NotFoundException('User profile not found');
    }

    const xpToNextLevel = 100 - (user.xp % 100);
    const xpProgress = (user.xp % 100) / 100;
    const giftValue = (user.proteinShakes * 5) + (user.proteinBars * 3);

    return {
      ...user,
      xpToNextLevel,
      xpProgress,
      giftValue,
    };
  }

  // ADD THIS METHOD
  async updateProfile(userId: number, updateData: any) {
    const updatedUser = await this.prisma.user.update({
      where: { id: userId },
      data: {
        ...updateData,
        onboardingCompleted: true, // Mark onboarding as complete
      },
    });

    // Generate new JWT with ALL user data
    const payload = {
      id: updatedUser.id,
      email: updatedUser.email,
      createdAt: updatedUser.createdAt,
      updatedAt: updatedUser.updatedAt,
      role: updatedUser.role,
      provider: updatedUser.provider,
      providerId: updatedUser.providerId,
      resetToken: updatedUser.resetToken,
      resetTokenExpiry: updatedUser.resetTokenExpiry,
      bio: updatedUser.bio,
      displayName: updatedUser.displayName,
      goals: updatedUser.goals,
      isUsernameAutoGenerated: updatedUser.isUsernameAutoGenerated,
      location: updatedUser.location,
      muscleGroups: updatedUser.muscleGroups,
      onboardingCompleted: updatedUser.onboardingCompleted,
      profilePictureUrl: updatedUser.profilePictureUrl,
      timezone: updatedUser.timezone,
      username: updatedUser.username,
      workoutTypes: updatedUser.workoutTypes,
      xp: updatedUser.xp,
      level: updatedUser.level,
      rubies: updatedUser.rubies,
      proteinShakes: updatedUser.proteinShakes,
      proteinBars: updatedUser.proteinBars,
      profileBoosts: updatedUser.profileBoosts,
      notifyBoosts: updatedUser.notifyBoosts,
      unlockedGifts: updatedUser.unlockedGifts,
      lastStreamCompletedAt: updatedUser.lastStreamCompletedAt,
    };

    const access_token = this.jwtService.sign(payload);

    return { access_token };
  }



  async getUserBalance(userId: number) {
  // Add this logging
  console.log(`üîç Getting balance for user ID: ${userId}`);
  
  const user = await this.prisma.user.findUnique({
    where: { id: userId },
    select: {
      id: true,  // Add this for debugging
      email: true, // Add this for debugging
      rubies: true,
      fitneksTokens: true,
      protein: true,
      proteinShakes: true,
      proteinBars: true,
    },
  });

  console.log(`üîç Found user:`, user); // Add this logging

  if (!user) {
    throw new NotFoundException('User not found');
  }

  const result = {
    rubies: user.rubies,
    fitneksTokens: user.fitneksTokens,
    protein: user.protein,
    proteinShakes: user.proteinShakes,
    proteinBars: user.proteinBars,
  };
  
  console.log(`üîç Returning balance:`, result); // Add this logging

  return result;
}




}