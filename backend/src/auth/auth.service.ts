// backend/src/auth/auth.service.ts

import {
  ForbiddenException,
  Injectable,
  BadRequestException,
  UnauthorizedException,
} from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { CreateUserDto, LoginUserDto } from './dto/auth.dto';
import { UpdateTrainerProfileDto } from './dto/update-profile.dto';
import { EmailService } from '../email/email.service';
import * as bcrypt from 'bcrypt';
import * as crypto from 'crypto';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { User, Role } from '@prisma/client';
import { UpdateLearnerProfileDto } from './dto/update-learner-profile.dto';

@Injectable()
export class AuthService {
  constructor(
    private prisma: PrismaService,
    private jwt: JwtService,
    private emailService: EmailService,
    private configService: ConfigService,
  ) {}

  // Helper function to generate a unique placeholder username
  private async _generateUniqueUsername(): Promise<string> {
    let username: string = ''; // <-- Give it an initial value
    let isUnique = false;
    while (!isUnique) {
      const randomNumbers = Math.floor(10000 + Math.random() * 90000);
      username = `User${randomNumbers}`;
      const existingUser = await this.prisma.user.findUnique({
        where: { username },
      });
      if (!existingUser) {
        isUnique = true;
      }
    }
    return username;
  }

  async register(createUserDto: CreateUserDto) {
  const salt = await bcrypt.genSalt();
  const hashedPassword = await bcrypt.hash(createUserDto.password, salt);

  const existingUser = await this.prisma.user.findUnique({
    where: { email: createUserDto.email },
  });
  if (existingUser) {
    throw new ForbiddenException('Credentials taken');
  }

  // Generate the creative username for ALL new users
  const username = await this._generateUniqueUsername();

  const user = await this.prisma.user.create({
    data: {
      email: createUserDto.email,
      password: hashedPassword,
      role: createUserDto.role,
      // Apply it to both username and displayName
      username: username,
      displayName: username,
    },
  });

  const { password, ...result } = user;
  return result;
}


  async validateUser(email: string, pass: string): Promise<any> {
    const user = await this.prisma.user.findUnique({ where: { email } });
    if (user && (await bcrypt.compare(pass, user.password))) {
      const { password, ...result } = user;
      return result;
    }
    return null;
  }

  // Update Trainer Profile
 async updateProfile(userId: number, dto: UpdateTrainerProfileDto) {
  const updatedUser = await this.prisma.user.update({
    where: { id: userId },
    data: {
      ...dto,
      onboardingCompleted: true,
    },
  });

  // Create sanitized payload
  const sanitizedUser = {
    ...updatedUser,
    xp: updatedUser.xp ?? 0,
    level: updatedUser.level ?? 0,
    rubies: updatedUser.rubies ?? 0,
    proteinShakes: updatedUser.proteinShakes ?? 0,
    proteinBars: updatedUser.proteinBars ?? 0,
    profileBoosts: updatedUser.profileBoosts ?? 0,
    notifyBoosts: updatedUser.notifyBoosts ?? 0,
  };

  // Remove password
  const { password, ...payload } = sanitizedUser;

  // Generate new token
const access_token = await this.jwt.signAsync(payload);


console.log('ðŸŽ« Generated access_token:', access_token);
console.log('ðŸ“¦ Returning:', { access_token });



  return { access_token };
}


  // Update Learner Profile 
async updateLearnerProfile(userId: number, dto: UpdateLearnerProfileDto) {
    const user = await this.prisma.user.update({
      where: {
        id: userId,
      },
      data: {
        username: dto.username,
        displayName: dto.displayName,
        location: dto.location,
        timezone: dto.timezone,
        workoutTypes: dto.workoutTypes,
        bio: dto.bio, // This will be saved as null if not provided
        goals: dto.goals,
        muscleGroups: dto.muscleGroups,
        isUsernameAutoGenerated: false, // User has now chosen their own name
        onboardingCompleted: true, // Mark onboarding as complete
      },
    });

    const { password, ...result } = user;
    return result;
  }


  async login(loginUserDto: LoginUserDto) {
    const user = await this.prisma.user.findUnique({
      where: { email: loginUserDto.email },
    });

    if (!user) {
      throw new UnauthorizedException('Incorrect login details. Try again or create an account.');
    }

    const pwMatches = await bcrypt.compare(
      loginUserDto.password,
      user.password,
    );

    if (!pwMatches) {
      throw new UnauthorizedException('Incorrect login details. Try again or create an account.');
    }
    const payload = { sub: user.id, email: user.email, role: user.role };
    return {
      access_token: await this.jwt.signAsync(payload),
    };
  }

  async validateOAuthUser(oauthUser: any) {
    const { email, provider, providerId } = oauthUser;
    let user = await this.prisma.user.findUnique({ where: { email } });
    if (!user) {
      const salt = await bcrypt.genSalt();
      const randomPassword = crypto.randomBytes(32).toString('hex');
      const hashedPassword = await bcrypt.hash(randomPassword, salt);
      const username = await this._generateUniqueUsername();
      user = await this.prisma.user.create({
        data: {
          email,
          password: hashedPassword,
          role: Role.Learner,
          provider,
          providerId,
          username: username,
          displayName: username,
        },
      });
    }
    return user;
  }

  async generateJwtForOAuthUser(user: any) {
    const payload = { sub: user.id, email: user.email, role: user.role };
    return {
      access_token: await this.jwt.signAsync(payload),
    };
  }

  async forgotPassword(email: string) {
    const user = await this.prisma.user.findUnique({
      where: { email },
    });

    if (!user) {
      return { message: 'If the email exists, a reset link has been sent.' };
    }

    const resetToken = crypto.randomBytes(32).toString('hex');
    const hashedToken = await bcrypt.hash(resetToken, 10);
    const expiresAt = new Date();
    expiresAt.setHours(expiresAt.getHours() + 1);

    await this.prisma.user.update({
      where: { id: user.id },
      data: {
        resetToken: hashedToken,
        resetTokenExpiry: expiresAt,
      },
    });

    const resetLink = `${this.configService.get('FRONTEND_URL')}/reset-password?token=${resetToken}`;
    await this.emailService.sendPasswordResetEmail(user.email, resetLink);

    return { message: 'If the email exists, a reset link has been sent.' };
  }

  async resetPassword(token: string, newPassword: string) {
    const users = await this.prisma.user.findMany({
      where: {
        resetTokenExpiry: {
          gt: new Date(),
        },
        resetToken: {
          not: null,
        },
      },
    });

    let validUser: User | null = null;
    for (const user of users) {
      if (
        user.resetToken &&
        (await bcrypt.compare(token, user.resetToken))
      ) {
        validUser = user;
        break;
      }
    }

    if (!validUser) {
      throw new BadRequestException('Invalid or expired reset token');
    }

    const salt = await bcrypt.genSalt();
    const hashedPassword = await bcrypt.hash(newPassword, salt);

    await this.prisma.user.update({
      where: { id: validUser.id },
      data: {
        password: hashedPassword,
        resetToken: null,
        resetTokenExpiry: null,
      },
    });

    return { message: 'Password successfully reset' };
  }
}